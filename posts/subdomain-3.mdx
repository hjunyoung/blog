---
title: [React] Subdomainë³„ë¡œ ë‹¤ë¥´ê²Œ ë™ì‘í•˜ëŠ” ì½”ë“œ ë¦¬íŒ©í† ë§í•˜ê¸° - 3. builder pattern í™œìš©
publishedAt: '2025-02-05T12:00:00.000Z'
summary: 'URL submainì— ë”°ë¼ ë‹¤ë¥´ê²Œ ë™ì‘í•˜ëŠ” ì½”ë“œ ë¦¬íŒ©í† ë§í•˜ê¸°'
tags: ['React', 'Refactoring', 'Builder Pattern']
---

[ì§€ë‚œ ê¸€](/blog/subdomain-2)ì—ì„  TypeScriptì˜ const enumìœ¼ë¡œ providerUtils.tsë¥¼ ê°œì„ í–ˆìŠµë‹ˆë‹¤.

ì´ë²ˆ ê¸€ì—ì„œëŠ” ë‘ë²ˆì§¸ ë¬¸ì œì ì„ ê°œì„ í•˜ê³  ê³ ê°ì‚¬ë³„ ê´€ë¦¬ë¥¼ ì‰½ê²Œí•˜ê¸° ìœ„í•´ builder patternì„ í™œìš©í•˜ì—¬ ë¦¬íŒ©í† ë§ í•œ ë°©ë²• ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.

# Problems

ê³ ê°ì‚¬ê°€ ëŠ˜ì–´ë‚˜ê³  ê³ ê°ì‚¬ë³„ë¡œ í• ì¸ ì ìš© ì—¬ë¶€, ìˆ˜ìˆ˜ë£Œ ì—¬ë¶€, ì ë¦½ê¸ˆ ì—¬ë¶€, ì§ì ‘ ë¡œê·¸ì¸ ê°€ëŠ¥ ì—¬ë¶€ ë“±, ê³ ê°ì‚¬ specificí•œ íŠ¹ì„±ë“¤ì´ ë§ì•„ì¡Œê³ , ì´ëŸ¬í•œ íŠ¹ì„±ë“¤ì„ êµ¬ë¶„í•˜ê¸° ìœ„í•´ ì•„ë˜ ì½”ë“œì™€ ê°™ì´ `array`ë¥¼ ì‚¬ìš©í•˜ê³  ìˆì—ˆìŠµë‹ˆë‹¤.

```ts
// providerUtils.ts

// í• ì¸ ì ìš©ë˜ëŠ” ê³ ê°ì‚¬
const providerWithDiscountList = [
  'provider1',
  'provider2',
  'provider3',
  'provider4',
  'provider5',
] as const;

// ìˆ˜ìˆ˜ë£Œ ë¶€ê³¼ë˜ëŠ” ê³ ê°ì‚¬
const providerWithCommissionList = ['provider6'] as const;

// ì ë¦½ê¸ˆ ì ìš©ë˜ëŠ” ê³ ê°ì‚¬
static providerWithPoint = [
  TestProvider.Dev,
  TestProvider.Local,
  SubdomainProvider.Provider1,
];

static isDiscountProvider =
  !this.provider ||
  this.providersWithDiscount.includes(this.provider as DiscountSubdomainType);
static isPointProvider =
  !this.provider ||
  this.providerWithPoint.includes(this.provider as SubdomainType);
static isDarkModeProvider =
  !this.provider ||
  this.darkModeProvider.includes(this.provider as SubdomainType);
static isLogoutUnavailableProvider = [
  SubdomainProvider.Provider1,
  SubdomainProvider.Provider2,
  TestProvider.Dev,
].includes(this.provider as SubdomainType);


static isProvider1 = [SubdomainProvider.Provider1, TestProvider.Provider6].includes(
  this.provider as SubdomainType
);
static isProvider2 = [SubdomainProvider.Provider2].includes(
  this.provider as SubdomainType
);

```

ì´ ë°©ì‹ì˜ ë¬¸ì œì ì€ `providersWithDiscount` , `providersWithCommission` ì²˜ëŸ¼ providerë§ˆë‹¤ ë‹¤ë¥¸ íŠ¹ì„±(e.g. ì§ì ‘ ë¡œê·¸ì•„ì›ƒ ê°€ëŠ¥, ì ë¦½ê¸ˆ ê¸°ëŠ¥ ì—¬ë¶€, íŠ¹ì • ëª¨ë“œ ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ â€¦)ì´ ì¶”ê°€ë˜ëŠ” ê²½ìš° ë§¤ë²ˆ Arrayì™€ is[íŠ¹ì„±]Provider í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ì„œ ê´€ë¦¬í•´ì•¼ í•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤.
ì´ëŸ° ê²½ìš° provider ê°ê°ì˜ íŠ¹ì„±ì´ provider ìì²´ì—ì„œ ê´€ë¦¬ë˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ì—¬ëŸ¬ êµ°ë°ì—ì„œ(ì—¬ëŸ¬ arrayë“¤) ê´€ë¦¬ë˜ì–´ ê´€ë¦¬í•˜ê¸°ê°€ ê¹Œë‹¤ë¡œì›Œ ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³ ê°ì‚¬ì— ì ìš©ë˜ëŠ” íŠ¹ì„±ì´ ë°”ë€ŒëŠ” ê²½ìš° íŠ¹ì„± ê´€ë ¨ Arrayë¥¼ ëŒì•„ë‹¤ë‹ˆë©° ë³€ê²½í•´ì•¼ í•©ë‹ˆë‹¤.

<br />

# Solutions

### builder pattern

ë‘ ë²ˆì§¸ ë¬¸ì œì ì€ arrayë¡œ ê³ ê°ì‚¬ë“¤ì„ ê´€ë¦¬í•˜ëŠ” ê²ƒìœ¼ë¡œë¶€í„° ì˜¤ëŠ” ìœ ì§€ë³´ìˆ˜ ë¬¸ì œì˜€ìŠµë‹ˆë‹¤.

ê³ ê°ì‚¬ì˜ íŠ¹ì„±ì„ ì—¬ëŸ¬ arrayì— ë‚˜ëˆ ì„œ ê´€ë¦¬í•˜ëŠ” ê²ƒ ëŒ€ì‹  ê³ ê°ì‚¬ classë¥¼ ë§Œë“¤ì–´ì„œ ê´€ë¦¬í•˜ì—¬ ì‘ì§‘ë„ë¥¼ ë†’ì´ê³  ìœ ì§€ë³´ìˆ˜ë¥¼ ì‰½ê²Œ í•˜ì˜€ê³ ,
ë˜ ê³ ê°ì‚¬ instanceë¥¼ ìƒì„±í•  ë•Œ constructorì— í•„ìš”í•œ ì¸ìê°€ ë§ê³ , ì•ìœ¼ë¡œ ì¶”ê°€ë  ìˆ˜ë„ ìˆê¸° ë•Œë¬¸ì— builder patternì„ ì‚¬ìš©í•˜ì—¬ ê³ ê°ì‚¬ ê°ì²´ ìƒì„±ì„ ì‰½ê²Œ í–ˆìŠµë‹ˆë‹¤.

```ts
// providerUtils.ts

class Domain {
  private static DomainBuilder = class {
    private _provider?: string;
    private _loginAvailable: boolean = true;
    private _point: boolean = true;
    private _discount: boolean = true;

    public provider(provider: string): this {
      this._provider = provider;
      return this;
    }

    public loginAvailable(loginAvailable: boolean): this {
      this._loginAvailable = loginAvailable;
      return this;
    }

    public point(point: boolean): this {
      this._point = point;
      return this;
    }

    public discount(discount: boolean): this {
      this._discount = discount;
      return this;
    }

    public build(): Domain {
      if (!this._provider) {
        throw new Error('provider field is required');
      }
      return new Domain(
        this._provider,
        this._loginAvailable,
        this._point,
        this._discount
        // this._twPrefix
      );
    }
  };

  protected constructor(
    public readonly provider: string,
    public readonly loginAvailable: boolean,
    public readonly point: boolean,
    public readonly discount: boolean
  ) {}

  protected static Builder(): InstanceType<typeof Domain.DomainBuilder> {
    return new Domain.DomainBuilder();
  }
}
```

ì´ë ‡ê²Œ Domain classë¥¼ ë§Œë“¤ì–´ì„œ providerë§ˆë‹¤ instanceë¥¼ ìƒì„±í•˜ì—¬ ê°ê°ì˜ íŠ¹ì„±ë“¤ì„ ê´€ë¦¬í•˜ë„ë¡ í–ˆìŠµë‹ˆë‹¤.

<br />

ì•„ë˜ì™€ ê°™ì´ builder patternì„ ì‚¬ìš©í•˜ì—¬ í•„ìš”í•œ íŠ¹ì„±ë“¤ë§Œ ì¶”ê°€í•˜ì—¬ ê³ ê°ì‚¬ instanceë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```ts
class Subdomain extends Domain {
  // Subdomain Objects created with Builder pattern
  private static Provider1: Domain = Subdomain.Builder()
    .provider('provider1')
    .loginAvailable(false)
    .build();
  private static Provider2: Domain = Subdomain.Builder()
    .provider('provider2')
    .build();
  private static Provider3: Domain = Subdomain.Builder()
    .provider('lottecard')
    .loginAvailable(false)
    .build();
  private static Provider4: Domain = Subdomain.Builder()
    .provider('provider4')
    .loginAvailable(false)
    .build();
}

class TestDomain extends Domain {
  // TestDomain Objects created with Builder pattern
  private static Provider6: Domain = TestDomain.Builder()
    .provider('provider6')
    .loginAvailable(false)
    .build();
  private static Dev: Domain = TestDomain.Builder().provider('test').build();
  private static Local: Domain = TestDomain.Builder()
    .provider('localhost')
    .build();
}
```

<br />

```ts
class BaseProviderUtils {
  private static getProviderListFrom(domain: typeof Domain) {
    return Object.getOwnPropertyNames(domain)
      .filter((key) => {
        // ì œì™¸í•  ê¸°ë³¸ static í•„ë“œ ëª©ë¡
        const excludedFields = ['length', 'name', 'prototype'];

        return (
          !excludedFields.includes(key) && // ê¸°ë³¸ í•„ë“œ ì œì™¸
          typeof domain[key as keyof typeof domain] !== 'function'
        );
      }) // í•¨ìˆ˜ê°€ ì•„ë‹Œ static í•„ë“œë§Œ í•„í„°ë§
      .map((key) => domain[key as keyof typeof domain]);
  }

  // ìš´ì˜ ê³ ê°ì‚¬ ë¦¬ìŠ¤íŠ¸
  private static prodProviderList = this.getProviderListFrom(Subdomain);

  // ê°œë°œ ê³ ê°ì‚¬ ë¦¬ìŠ¤íŠ¸
  private static devProviderList = this.getProviderListFrom(TestDomain);

  // ì „ì²´ ê³ ê°ì‚¬ ë¦¬ìŠ¤íŠ¸
  private static providerList = [
    ...this.prodProviderList,
    ...this.devProviderList,
  ];

  // provider
  private static getProvider() {
    const subdomain = window.location.hostname.split('.')[0];

    const getProvider = (subdomain: string) => {
      return this.providerList.find(
        (provider) => provider.provider === subdomain
      );
    };

    return getProvider(subdomain);
  }

  public static get provider() {
    return this.getProvider();
  }
}

class CategoryProviderUtils extends BaseProviderUtils {
  static discountAvailable = !this.provider || this.provider.discount;
  static pointAvailable = !this.provider || this.provider.point;
  static loginAvailable = !this.provider || this.provider.loginAvailable;

  static isDev = ['test', 'localhost'].includes(
    this.provider?.provider as string
  );
}

export class ProviderUtils extends CategoryProviderUtils {
  // Dynamically set isProvider static propeties for each provider
  // TypeScriptâ€™s static type checking is based on explicitly declared properties
  static readonly isProvider1: boolean;
  static readonly isProvider2: boolean;
  static readonly isProvider3: boolean;
  static readonly isProvider4: boolean;
  static readonly isProvider5: boolean;
  static readonly isProvider6: boolean;

  /**
   * Dynamically defines static boolean properties on the ProviderUtils class
   * for each provider in the Subdomain class. These properties are prefixed
   * with 'is' followed by the provider's name (e.g., isProvider1). Each property
   * indicates whether the current provider matches the respective provider.
   *
   * The method filters out non-provider static fields and functions from
   * the Subdomain class, then uses Object.defineProperty to create the properties.
   * These properties are non-writable and non-configurable.
   */
  static setIsProviderProperties() {
    const excludedFields = ['length', 'name', 'prototype'];
    Object.getOwnPropertyNames(Subdomain)
      .filter(
        (key) =>
          !excludedFields.includes(key) && // ê¸°ë³¸ í•„ë“œ ì œì™¸
          typeof Subdomain[key as keyof typeof Subdomain] !== 'function' // í•¨ìˆ˜ ì œì™¸
      )
      .forEach((key) => {
        const propertyName = `is${key}`;
        Object.defineProperty(ProviderUtils, propertyName, {
          value: [
            Subdomain[key as keyof typeof Subdomain].provider,
            TestDomain[key as keyof typeof TestDomain].provider,
          ].includes(this.provider?.provider as string),
          writable: false,
          configurable: false,
        });
      });
  }
}
```

ì‹¤ì œ component íŒŒì¼ì—ì„œ ì‚¬ìš©í•  ProviderUtils í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ê³ , Object.definePropertyë¥¼ í™œìš©í•˜ì—¬ íŠ¹ì • ê³ ê°ì‚¬ì¸ì§€ í™•ì¸í•  ìˆ˜ ìˆëŠ” static propertiesë¥¼ ë™ì ìœ¼ë¡œ ìƒì„±í•´ ì£¼ì—ˆìŠµë‹ˆë‹¤.
TypeScriptì˜ static type checkingì„ ìœ„í•´ ProviderUtils classì— is[Provider] static propertiesë¥¼ ì„ ì–¸í•´ì£¼ì–´ í•˜ì§€ë§Œ, Arrayë¡œ ê³ ê°ì‚¬ë“¤ì„ ê´€ë¦¬í•  ë•Œ, is[Provider]Provider í•¨ìˆ˜ë“¤ì„ ì§ì ‘ ë§Œë“¤ì–´ì•¼ í•˜ëŠ” ê²ƒë³´ë‹¤ëŠ” ë” ë‚˜ì€ ë°©ë²•ì´ë¼ê³  ìƒê°í•©ë‹ˆë‹¤.

# Summary

ì´ë²ˆ ë¦¬íŒ©í† ë§ì„ í†µí•´ ë‹¬ì„±í•œ ì£¼ìš” ê°œì„  ì‚¬í•­ì€ ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤.

1. ì‘ì§‘ë„ í–¥ìƒ

   Providerë³„ íŠ¹ì„±ì„ ê°œë³„ arrayê°€ ì•„ë‹Œ ë‹¨ì¼ í´ë˜ìŠ¤ì—ì„œ ê´€ë¦¬í•¨ìœ¼ë¡œì¨ íŠ¹ì„± ë³€ê²½ ì‹œ í•´ë‹¹ Provider ì¸ìŠ¤í„´ìŠ¤ë§Œ ìˆ˜ì •í•˜ë©´ ë˜ì–´ ìœ ì§€ë³´ìˆ˜ê°€ ì‰¬ì›Œì¡ŒìŠµë‹ˆë‹¤.

2. ìœ ì—°í•œ ê°ì²´ ìƒì„±

   Builder patternìœ¼ë¡œ Provider ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ê³¼ì •ì„ ë‹¨ìˆœí™”í•˜ê³  ì„ íƒì  íŠ¹ì„±ì„ ìœ ì—°í•˜ê²Œ ì„¤ì •í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

{/* TODO */}
{/* builder íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ ë°”ê¾¼ ì´ìœ  ì •ë¦¬ - https://inpa.tistory.com/entry/GOF-ğŸ’ -ë¹Œë”Builder-íŒ¨í„´-ëíŒì™•-ì •ë¦¬ */}

{/* # ì°¸ê³ ìë£Œ */}
